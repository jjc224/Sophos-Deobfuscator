#!/usr/bin/env ruby

#  ---------------------------------------------------------------------------------------------------------------------------------
# | Sophos Enterprise Console username/password deobfuscator                                                               03/12/18 |
# |                                                                                                                                 |
# | Author: Joshua Coleman                                                                                                          |
# | Usage:  ruby sophos_deobfuscate.rb <obfuscated>                                                                                 |
# |                                                                                                                                 |
# | ObfuscationUtil.exe is a tool provided by Sophos to obfuscate administrator account credentials:                                |
# |   ObfuscationUtil.exe --obfuscate <USERNAME> -w                                                                                 |
# |   ObfuscationUtil.exe --obfuscate <PASSWORD> -w                                                                                 |
# |                                                                                                                                 |
# |   "Where <USERNAME> and <PASSWORD> are the username and password that are needed to obfuscate.                                  |
# |   These credentials should have administrator privileges to access the files in the CID."                                       |
# |     - https://community.sophos.com/kb/en-us/13094                                                                               |
# |                                                                                                                                 |
# |   Sidenote: The -w flag is optional and outputs the obfuscated data as a wstring.                                               |
# |             Each character is of type wchar_t - it's size is compiler-dependent.                                                |
# |             8, 16, or 32 bits - signed or unsigned.                                                                             |
# |                                                                                                                                 |
# | This tool is able to deobfuscate obfuscated strings (standard or wide) generated by SEC's ObfuscationUtil.exe.                  |
# |                                                                                                                                 |
# | Usage example:                                                                                                                  |
# |  --------------------------------------------------------------------------------------------------------------------           |
# | | [josh@poseidon]> awk 'NF > 1 {print $4}' obfuscated_password.txt                                                   |          |
# | |   Bwg09ImSa/lhAgB3NzKRnrBY1aU5eQFHQTursgQOjutmYw==                                                                 |          |
# | |                                                                                                                    |          |
# | | [josh@poseidon]> ruby sophos_deobfuscate.rb 'Bwg09ImSa/lhAgB3NzKRnrBY1aU5eQFHQTursgQOjutmYw=='                     |          |
# | |   Data:           00773732919eb058d5a539790147413babb2040e8eeb6663                                                 |          |
# | |   Password (KDF): 5644b2629112c5facfd15923e8f097493b73455eae613454485bc61f785f0008b340fc34e05ad98b71aed70dab3e97c9 |          |
# | |   Salt:           34f489926bf96102                                                                                 |          |
# | |   Key:            2d56cd87125373fab364c2df196cf29a05e4c8f1a1c99ada                                                 |          |
# | |   IV:             3e4f6d9aa6069a61                                                                                 |          |
# | |                                                                                                                    |          |
# | |   Deobfuscated:   ReallyGoodPassword                                                                               |          |
# |  --------------------------------------------------------------------------------------------------------------------           |
#  ---------------------------------------------------------------------------------------------------------------------------------

require 'base64'
require 'digest'
require 'openssl'

# Notes on the Sophos obfuscation tool - ObfuscationUtil.exe:
#   Given a 64-bit block size, it's safe to assume DES/3DES with PKCS#5 padding is in-use.
#   This is then base64-encoded.
#   The salt and IV must necessarily be embedded in the obfuscated string itself in order for Sophos to deobfuscate it given its dynamic nature.
#     (i.e., when you obfuscate two identical inputs, you will acquire different output.)
#   The standard/proper way of doing this would be by via a KDF (key derivation function).
#
#   Reverse engineering the binary showed this to be the case.
#   Details are included in comments where appropriate.

abort('Usage: ruby deobfuscate.rb <obfuscated>') if ARGV.empty?

# [josh@poseidon] [/dev/ttys008] [~/Scripts/Sophos]> awk 'NF > 1 {print $4}' /Volumes/Intranet/Temp/Josh/obfuscated.txt | base64 -D | xxd
# 00000000: 0708 351d 1a18 f825 b3cf 733e 05e5 eea5  ..5....%..s>....
#            ^
#            |__ All obfuscated strings begin with 0x0708.
def valid?(decoded64)
  decoded64[0..1] == [0x07, 0x08].pack('C*')
end

# Sophos implements OpenSSL's DES-EDE3-CBC via LIBEAY32.DLL:
#   0015B98A   $-FF25 68D01500  JMP DWORD PTR DS:[<&LIBEAY32.#255>]      ;  LIBEAY32.EVP_BytesToKey
#   0015B990   $-FF25 B0D01500  JMP DWORD PTR DS:[<&LIBEAY32.#323>]      ;  LIBEAY32.EVP_md5
#   0015B996   $-FF25 6CD01500  JMP DWORD PTR DS:[<&LIBEAY32.#304>]      ;  LIBEAY32.EVP_des_ede3_cbc
#   0015B99C   $-FF25 70D01500  JMP DWORD PTR DS:[<&LIBEAY32.#274>]      ;  LIBEAY32.EVP_EncryptFinal
#
# An implementation of OpenSSL's PKCS#5 EVP_BytesToKey(), which is a simple (and insecure/deprecated) KDF (key derivation function):
#   D_i = HASH^count(D_(i-1) || data || salt)
#
# (Three-key) Triple-DES has a key-size of 192 bits and a 64-bit IV.
#
# "This is a single iteration of MD5 over the concatenation of the password and 8 bytes of random ASCII salt."
#   - https://cwiki.apache.org/confluence/display/NIFI/Key+Derivation+Function+Explanations
def derive_key_and_iv(password, salt, count = 1, key_size = 48, iv_size = 16)
  hashes    = []
  hashes[0] = Digest::MD5.hexdigest(password + salt)

  (count - 1).times do |i|
    hashes[0] = Digest::MD5.hexdigest(hashes[0])
  end

  digest_size = key_size + iv_size
  i = 1

  while(hashes.join.size < digest_size)
    prev_hash = [hashes[i - 1]].pack('H*')  # The previous hash/digest in raw bytes (from hex).
    hashes[i] = Digest::MD5.hexdigest(prev_hash + password + salt)

    i += 1
  end

  digest = hashes.join
  key    = digest[0...key_size]
  iv     = digest[key_size..-1]

  [key, iv]
end


# int EVP_BytesToKey(const EVP_CIPHER *type, const EVP_MD *md,
#                    const unsigned char *salt, const unsigned char *data,
#                    int datal, int count,
#                    unsigned char *key, unsigned char *iv);
#
# 1. Breakpoint at EVP_BytesToKey (libeay32.dll).
# 2. Identify the pointer to the unsigned char which contains the password data:
#
#   That would be the fourth argument (const unsigned char *data).
#
#   010FF02C  00D19965  RETURN to Obfuscat.00D19965 from <JMP.&LIBEAY32.#255>    <-- ESP
#   010FF030  714E4814  LIBEAY32.714E4814                                        <-- const EVP_CIPHER *type     (ESP + 0x04)
#   010FF034  714E5DC8  LIBEAY32.714E5DC8                                        <-- const EVP_MD *md           (ESP + 0x08)
#   010FF038  00123490                                                           <-- const unsigned char *salt  (ESP + 0x0C)
#   010FF03C  00123938                                                           <-- const unsigned char *data  (ESP + 0x10)
#   010FF040  00000030                                                           <-- int data1 (= 0x30 = 48)    (ESP + 0x14)
#   010FF044  00000001                                                           <-- int count (= 1)            (ESP + 0x18)
#
#       __ Address at ESP + 0x10 (const unsigned char *data): take `int datal` (48) worth of bytes.
#      |
#      v
#   00123938  56 44 B2 62 91 12 C5 FA  VD²b‘Åú
#   00123940  CF D1 59 23 E8 F0 97 49  ÏÑY#èð—I
#   00123948  3B 73 45 5E AE 61 34 54  ;sE^®a4T
#   00123950  48 5B C6 1F 78 5F 00 08  H[Æx_.
#   00123958  B3 40 FC 34 E0 5A D9 8B  ³@ü4àZÙ‹
#   00123960  71 AE D7 0D AB 3E 97 C9  q®×.«>—É

password_bytes = [
  0x56, 0x44, 0xB2, 0x62, 0x91, 0x12, 0xC5, 0xFA, 0xCF, 0xD1,
  0x59, 0x23, 0xE8, 0xF0, 0x97, 0x49, 0x3B, 0x73, 0x45, 0x5E,
  0xAE, 0x61, 0x34, 0x54, 0x48, 0x5B, 0xC6, 0x1F, 0x78, 0x5F,
  0x00, 0x08, 0xB3, 0x40, 0xFC, 0x34, 0xE0, 0x5A, 0xD9, 0x8B,
  0x71, 0xAE, 0xD7, 0x0D, 0xAB, 0x3E, 0x97, 0xC9
]

enc = ARGV[0]
dec = Base64.decode64(enc)

abort('Error: not a valid obfuscated string.') unless valid?(dec)

salt = dec[2...10]  # The salt is embedded in the byte following the obfuscation signature ([0x07, 0x08]).
data = dec[10..-1]  # The rest is our encrypted/obfuscated (padded) data.

password = password_bytes.pack('C*')
key, iv  = derive_key_and_iv(password, salt)

cipher = OpenSSL::Cipher.new('DES-EDE3-CBC')
cipher.decrypt

cipher.key = [key].pack('H*')
cipher.iv  = [iv].pack('H*')
decrypted  = cipher.update(data) + cipher.final

printf("%-15s %s\n", "Data:", "#{data.unpack('H*')[0]}")
printf("%-15s %s\n", "Password (KDF):", "#{password.unpack('H*')[0]}")
printf("%-15s %s\n", "Salt:", "#{salt.unpack('H*')[0]}")
printf("%-15s %s\n", "Key:", "#{key}")
printf("%-15s %s\n", "IV:", "#{iv}")
puts
printf("%-15s %s\n", "Deobfuscated:", "#{decrypted}")
